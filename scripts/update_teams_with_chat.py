#!/usr/bin/env python3
"""
Update existing teams with WebSocket chat support.
This script regenerates team_server.py files for teams that should have chat enabled.
"""

import os
import shutil
import sys
from datetime import datetime
from pathlib import Path

# Add project root to path
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Teams that should have chat enabled
CHAT_ENABLED_TEAMS = {
    "executive-team": {
        "is_top_level": True,
        "chat_config": {
            "allowed_roles": ["admin", "user"],
            "max_session_duration_minutes": 60,
            "max_messages_per_session": 100,
            "enable_delegation_preview": True,
            "context_window_messages": 20,
            "require_user_confirmation": True,
        },
    },
    "engineering-team": {
        "is_top_level": True,
        "chat_config": {
            "allowed_roles": ["admin", "user"],
            "max_session_duration_minutes": 45,
            "max_messages_per_session": 50,
            "enable_delegation_preview": True,
            "context_window_messages": 20,
            "require_user_confirmation": True,
        },
    },
    "marketing-team": {
        "is_top_level": True,
        "chat_config": {
            "allowed_roles": ["admin", "user"],
            "max_session_duration_minutes": 45,
            "max_messages_per_session": 50,
            "enable_delegation_preview": True,
            "context_window_messages": 20,
            "require_user_confirmation": True,
        },
    },
}


def update_team_server(team_dir: Path, team_name: str, chat_config: dict) -> bool:
    """
    Update team_server.py with WebSocket chat support.

    Args:
        team_dir: Path to team directory
        team_name: Name of the team
        chat_config: Chat configuration

    Returns:
        True if successful
    """
    server_file = team_dir / "team_server.py"

    if not server_file.exists():
        print(f"  âŒ team_server.py not found in {team_dir}")
        return False

    # Backup existing file
    backup_file = (
        team_dir / f"team_server.py.backup.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    )
    shutil.copy(server_file, backup_file)
    print(f"  ðŸ“„ Backed up to {backup_file.name}")

    # Read existing file to extract key information
    with open(server_file, "r") as f:
        content = f.read()

    # Extract framework (CrewAI or LangGraph)
    framework = "CrewAI" if "from crew import" in content else "LangGraph"

    # Extract department
    department = "executive" if "executive" in team_name else "general"

    # Extract purpose from docstring or description
    purpose_start = content.find('description="') + 13
    if purpose_start > 13:
        purpose_end = content.find('"', purpose_start)
        purpose = content[purpose_start:purpose_end]
    else:
        purpose = f"Team for {team_name.replace('-', ' ')}"

    # Extract agents list
    agents = []
    agents_start = content.find("agents: List[str] = [")
    if agents_start > -1:
        agents_end = content.find("]", agents_start)
        agents_str = content[agents_start : agents_end + 1]
        # Parse the list
        import ast

        try:
            agents_line = agents_str.split("=")[1].strip()
            agents = ast.literal_eval(agents_line)
        except:
            agents = ["Manager", "Specialist"]

    # Determine manager
    manager_name = "Manager"
    manager_role = "Team Manager"
    for agent in agents:
        if any(
            term in agent.lower()
            for term in ["manager", "lead", "head", "ceo", "cto", "cmo", "coo", "cfo"]
        ):
            manager_name = agent
            manager_role = agent
            break

    # Generate new content with chat support
    new_content = f'''#!/usr/bin/env python3
"""
Team Server - Runs the {framework} team with A2A protocol endpoint and WebSocket chat
Generated by Team Factory (Updated for Chat Support)
"""

import asyncio
import logging
import os
from datetime import datetime
from typing import Any, Dict, List, Optional

import uvicorn
from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.responses import JSONResponse
from pydantic import BaseModel

# Team imports
{"from crew import get_orchestrator" if framework == "CrewAI" else "from workflows.team_workflow import get_workflow"}
from agents.distributed.a2a.messages import TaskRequest, TaskResponse
from agents.distributed.a2a.server import A2AServer

# Chat imports
try:
    from elf_automations.shared.auth.jwt_handler import require_websocket_auth, get_jwt_handler
    from elf_automations.shared.chat import ConversationManager
    import json
    CHAT_ENABLED = True
except ImportError:
    CHAT_ENABLED = False
    print("Warning: Chat dependencies not found. WebSocket chat will be disabled.")

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title="{team_name} Team API",
    description="A2A-enabled {framework} team for {purpose}",
    version="1.0.0",
)

# Initialize team orchestrator
{"orchestrator" if framework == "CrewAI" else "workflow"} = None
a2a_server = None
conversation_manager = None
jwt_handler = None


class TaskRequestModel(BaseModel):
    """Model for incoming task requests"""

    from_agent: str
    to_agent: str
    task_type: str
    task_description: str
    context: Dict[str, Any] = {{}}
    timeout: int = 3600  # Default 1 hour


class HealthResponse(BaseModel):
    """Health check response model"""

    status: str
    team_name: str = "{team_name}"
    framework: str = "{framework}"
    department: str = "{department}"
    timestamp: str
    agents: List[str] = {agents}
    chat_enabled: bool = CHAT_ENABLED


@app.on_event("startup")
async def startup_event():
    """Initialize team on startup"""
    global {"orchestrator" if framework == "CrewAI" else "workflow"}, a2a_server, conversation_manager, jwt_handler

    logger.info("Starting {team_name} team server...")

    # Initialize orchestrator
    {"orchestrator = get_orchestrator()" if framework == "CrewAI" else "workflow = get_workflow()"}
    logger.info("Team orchestrator initialized")

    # Initialize A2A server
    a2a_server = A2AServer(
        agent_id="{team_name}-manager",
        capabilities=[
            "{purpose}",
            "Task execution",
            "Status reporting",
            "Team coordination",
        ],
    )
    await a2a_server.start()
    logger.info("A2A server initialized")

    # Initialize chat interface if enabled
    if CHAT_ENABLED:
        try:
            jwt_handler = get_jwt_handler()

            # Get manager agent from orchestrator
            manager_agent = None
            if hasattr({"orchestrator" if framework == "CrewAI" else "workflow"}, 'manager'):
                manager_agent = {"orchestrator" if framework == "CrewAI" else "workflow"}.manager
            elif hasattr({"orchestrator" if framework == "CrewAI" else "workflow"}, 'agents') and {"orchestrator" if framework == "CrewAI" else "workflow"}.agents:
                # Find manager agent
                for agent in {"orchestrator" if framework == "CrewAI" else "workflow"}.agents:
                    if hasattr(agent, 'role') and any(term in agent.role.lower() for term in ["manager", "lead", "head"]):
                        manager_agent = agent
                        break

            conversation_manager = ConversationManager(
                team_agent=manager_agent,
                team_name="{team_name}",
                manager_name="{manager_name}",
                manager_role="{manager_role}",
                chat_config={repr(chat_config)}
            )
            logger.info("Chat interface initialized")
        except Exception as e:
            logger.error(f"Failed to initialize chat interface: {{e}}")
            CHAT_ENABLED = False

    logger.info("{team_name} team server started successfully")


@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown"""
    global a2a_server

    logger.info("Shutting down {team_name} team server...")

    if a2a_server:
        await a2a_server.stop()

    logger.info("Shutdown complete")


@app.get("/health", response_model=HealthResponse)
async def health_check():
    """Health check endpoint"""
    return HealthResponse(status="healthy", timestamp=datetime.utcnow().isoformat())


@app.post("/task")
async def handle_task(request: TaskRequestModel):
    """Handle incoming A2A task requests"""
    logger.info(
        f"Received task from {{request.from_agent}}: {{request.task_description[:100]}}..."
    )

    try:
        # Create task request
        task_request = TaskRequest(
            from_agent=request.from_agent,
            to_agent=request.to_agent,
            task_type=request.task_type,
            task_description=request.task_description,
            context=request.context,
            timeout=request.timeout,
        )

        # Execute task using orchestrator
        if "{framework}" == "CrewAI":
            result = {"orchestrator" if framework == "CrewAI" else "workflow"}.run(
                task_description=request.task_description, context=request.context
            )
        else:
            # LangGraph async execution
            result = await {"orchestrator" if framework == "CrewAI" else "workflow"}.run(
                objective=request.task_description, context=request.context
            )

        # Create response
        response = TaskResponse(
            request_id=task_request.request_id,
            from_agent=request.to_agent,
            to_agent=request.from_agent,
            status="completed",
            result=str(result),
            context={{
                "execution_time": datetime.utcnow().isoformat(),
                "team_name": "{team_name}",
            }},
        )

        logger.info(f"Task completed successfully for {{request.from_agent}}")
        return response.dict()

    except Exception as e:
        logger.error(f"Error executing task: {{str(e)}}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/capabilities")
async def get_capabilities():
    """Return team capabilities"""
    capabilities = [
        "{purpose}",
        "Task execution via {framework}",
        "A2A protocol support",
        "Status reporting",
        "Health monitoring",
    ]

    if CHAT_ENABLED:
        capabilities.append("WebSocket chat interface for interactive task delegation")

    return {{
        "team_name": "{team_name}",
        "department": "{department}",
        "framework": "{framework}",
        "purpose": "{purpose}",
        "agents": [
            {{"role": agent, "is_manager": agent == "{manager_name}"}}
            for agent in {agents}
        ],
        "capabilities": capabilities,
        "chat_enabled": CHAT_ENABLED,
    }}


@app.get("/status")
async def get_status():
    """Get current team status"""
    return {{
        "status": "operational",
        "team_name": "{team_name}",
        "active_tasks": 0,  # Would track actual tasks in production
        "last_activity": datetime.utcnow().isoformat(),
        "agents_status": {{
            agent: "ready" for agent in {agents}
        }},
        "chat_enabled": CHAT_ENABLED,
    }}


if CHAT_ENABLED:
    @app.websocket("/chat")
    @require_websocket_auth(jwt_handler)
    async def chat_endpoint(websocket: WebSocket):
        """WebSocket endpoint for team chat interface."""
        await websocket.accept()

        # Get user info from JWT
        user_id = websocket.state.user_id
        team_id = websocket.state.team_id
        session_id = websocket.state.session_id or None

        # Verify team access
        if team_id != "{team_name}":
            await websocket.close(code=1008, reason="Invalid team access")
            return

        # Start or resume session
        if not session_id:
            session_id, greeting = await conversation_manager.start_session(
                user_id=user_id,
                initial_context={{"source": "websocket", "team_id": team_id}}
            )

            # Send greeting
            await websocket.send_json({{
                "type": "greeting",
                "session_id": session_id,
                "message": greeting,
                "manager": "{manager_name}",
                "team": "{team_name}"
            }})

        try:
            while True:
                # Receive message from user
                data = await websocket.receive_json()

                if data.get("type") == "end_session":
                    # End the session
                    summary = await conversation_manager.end_session(
                        session_id,
                        reason="user_ended"
                    )
                    await websocket.send_json({{
                        "type": "session_ended",
                        "summary": summary
                    }})
                    break

                # Process chat message
                user_message = data.get("message", "")
                if not user_message:
                    continue

                # Send thinking indicator
                await websocket.send_json({{
                    "type": "status",
                    "status": "thinking"
                }})

                # Process with conversation manager
                response = await conversation_manager.process_message(
                    session_id=session_id,
                    user_message=user_message,
                    context=data.get("context", {{}})
                )

                # Send response
                await websocket.send_json({{
                    "type": "message",
                    "content": response["response"],
                    "thinking_time": response["thinking_time"],
                    "ready_to_delegate": response["ready_to_delegate"],
                    "metadata": {{
                        "message_count": response["message_count"],
                        "total_tokens": response["total_tokens"]
                    }}
                }})

                # If ready to delegate, send delegation preview
                if response["ready_to_delegate"]:
                    delegation_spec = conversation_manager.prepare_delegation(session_id)
                    if delegation_spec:
                        await websocket.send_json({{
                            "type": "delegation_preview",
                            "delegation": delegation_spec,
                            "requires_confirmation": True
                        }})

        except WebSocketDisconnect:
            logger.info(f"Chat session disconnected for user {{user_id}}")
            # Clean up session
            await conversation_manager.end_session(session_id, reason="disconnected")
        except Exception as e:
            logger.error(f"Chat error: {{str(e)}}")
            await websocket.close(code=1011, reason="Internal error")


    @app.post("/chat/delegation/confirm")
    async def confirm_delegation(
        session_id: str,
        confirmed: bool,
        modifications: Optional[Dict[str, Any]] = None
    ):
        """Confirm or reject a delegation after chat session."""
        if not conversation_manager:
            raise HTTPException(status_code=503, detail="Chat interface not initialized")

        if not confirmed:
            return {{"status": "delegation_cancelled"}}

        # Get delegation spec
        delegation_spec = conversation_manager.prepare_delegation(session_id)
        if not delegation_spec:
            raise HTTPException(status_code=404, detail="No delegation found for session")

        # Apply modifications if any
        if modifications:
            delegation_spec.update(modifications)

        # Create A2A task from delegation
        task_request = TaskRequestModel(
            from_agent="chat_interface",
            to_agent="{manager_name}",
            task_type="delegated_from_chat",
            task_description=delegation_spec.get("description", ""),
            context=delegation_spec
        )

        # Execute through normal task flow
        response = await handle_task(task_request)

        # End chat session
        await conversation_manager.end_session(session_id, reason="delegation_complete")

        return {{
            "status": "delegation_confirmed",
            "task_id": response.get("task_id"),
            "delegation": delegation_spec
        }}


if __name__ == "__main__":
    # Run the server
    port = int(os.getenv("PORT", "8000"))
    host = os.getenv("HOST", "0.0.0.0")

    logger.info(f"Starting server on {{host}}:{{port}}")

    uvicorn.run(app, host=host, port=port, log_level="info", access_log=True)
'''

    # Write new content
    with open(server_file, "w") as f:
        f.write(new_content)

    print(f"  âœ… Updated team_server.py with WebSocket chat support")

    return True


def update_requirements(team_dir: Path) -> bool:
    """Update requirements.txt with WebSocket dependencies."""
    req_file = team_dir / "requirements.txt"

    if not req_file.exists():
        print(f"  âš ï¸  requirements.txt not found, creating...")
        req_file.touch()

    with open(req_file, "r") as f:
        content = f.read()

    deps_to_add = []

    # Check for WebSocket dependencies
    if "websockets" not in content:
        deps_to_add.append("websockets>=10.0")

    if "PyJWT" not in content and "python-jwt" not in content:
        deps_to_add.append("PyJWT>=2.8.0")

    if deps_to_add:
        with open(req_file, "a") as f:
            if not content.endswith("\n"):
                f.write("\n")
            f.write("\n".join(deps_to_add) + "\n")
        print(f"  ðŸ“¦ Added dependencies: {', '.join(deps_to_add)}")
    else:
        print(f"  âœ“ All dependencies already present")

    return True


def main():
    """Update teams with WebSocket chat support."""
    print("ðŸš€ Updating teams with WebSocket chat support\n")

    # Find team directories
    team_dirs = []
    search_paths = [
        PROJECT_ROOT / "teams",
        PROJECT_ROOT / "src" / "teams" / "teams",
    ]

    for search_path in search_paths:
        if search_path.exists():
            for team_name, config in CHAT_ENABLED_TEAMS.items():
                team_dir = search_path / team_name
                if team_dir.exists() and team_dir.is_dir():
                    team_dirs.append((team_dir, team_name, config))

    if not team_dirs:
        print("âŒ No team directories found!")
        return 1

    print(f"Found {len(team_dirs)} teams to update:\n")

    success_count = 0
    for team_dir, team_name, config in team_dirs:
        print(f"ðŸ“ {team_name} ({team_dir})")

        # Update team_server.py
        if update_team_server(team_dir, team_name, config["chat_config"]):
            # Update requirements.txt
            update_requirements(team_dir)
            success_count += 1

        print()

    print(f"\nâœ… Successfully updated {success_count}/{len(team_dirs)} teams")

    if success_count > 0:
        print("\nðŸ“‹ Next steps:")
        print("1. Review the updated team_server.py files")
        print("2. Test locally: cd <team-dir> && python team_server.py")
        print("3. Rebuild Docker images for each team")
        print("4. Deploy to Kubernetes")
        print("\nðŸ’¡ To rebuild all images:")
        print("   for team in executive-team engineering-team marketing-team; do")
        print("     cd src/teams/teams/$team")
        print("     docker build -t $team .")
        print("   done")

    return 0 if success_count == len(team_dirs) else 1


if __name__ == "__main__":
    sys.exit(main())
